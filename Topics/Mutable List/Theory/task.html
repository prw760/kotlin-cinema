<div class="step-text">
<p>You already know quite a lot about collections. In the previous topics, you got familiar with <code class="language-kotlin">List</code>. In this topic, we return to an already familiar <code class="language-kotlin">MutableList</code> collection. You already know how to work with <code class="language-kotlin">MutableList</code>, so we recap this knowledge and discuss when and how it is used, where it differs from <code class="language-kotlin">List</code> and what its main purpose is.</p>
<h5 id="introduction">Introduction</h5>
<p>Let's recap: <code class="language-kotlin">List</code> is a collection. <code class="language-kotlin">List</code> has a lot of methods and properties out-of-the-box. You cannot make changes to the elements of a <code class="language-kotlin">List</code> because it is immutable. Now we will learn about its mutable twin brother.<br/><br/><code class="language-kotlin">MutableList</code> is another version of <code class="language-kotlin">List</code>. It allows duplicates and stores elements in a specific order. In contrast to <code class="language-kotlin">List</code>, <code class="language-kotlin">MutableList</code> is a mutable or modifiable collection that allows you to add and remove elements. <code class="language-kotlin">MutableList</code> includes functions such as <code class="language-kotlin">add</code>, <code class="language-kotlin">remove</code>, and <code class="language-kotlin">clear</code>.</p>
<p>Imagine you decided to keep a <code class="language-kotlin">List</code> of all the places you've been to:</p>
<pre><code class="language-kotlin">val places = listOf&lt;String&gt;("Paris", "Moscow", "Tokyo")
println(places) // output: [Paris, Moscow, Tokyo]</code></pre>
<p>You keep travelling, and your most recent trip was to Saint Petersburg. You want to add it to your <code class="language-kotlin">List</code> of places, but there is a problem: you cannot add another item to the <code class="language-kotlin">List</code> because it is <strong>immutable</strong>. You can do this by reassigning, but this is a slow and inefficient way:</p>
<pre><code class="language-kotlin">var places = listOf&lt;String&gt;("Paris", "Moscow", "Tokyo") // note var keyword
places += "Saint-Petersburg" // reassignment, slow operation
println(places) // output: [Paris, Moscow, Tokyo, Saint-Petersburg]</code></pre>
<p>This is where <code class="language-kotlin">MutableList</code> comes to our rescue. As we said before, <code class="language-kotlin">MutableList</code> supports adding elements. So, let's switch to <code class="language-kotlin">MutableList</code> and add one more element:</p>
<pre><code class="language-kotlin">val places = mutableListOf&lt;String&gt;("Paris", "Moscow", "Tokyo")
places.add("Saint-Petersburg")
println(places) // output: [Paris, Moscow, Tokyo, Saint-Petersburg]</code></pre>
<h5 id="key-differences">Key Differences:</h5>
<ol><li><p><strong>Mutability</strong>:</p><ul><li><p><code class="language-kotlin">MutableList</code> lets you make changes after it's created.</p></li><li><p>The <a class="theory-lookup not-relevant" href="/learn/step/11032" target="_blank" title="In Kotlin, an immutable is a type of object or variable that, once initialized, cannot be changed. | This helps ensure the integrity of data and prevents unintended modifications. For example, a list of pages in a book may be an immutable collection, where the content cannot be altered over time. In contrast, a mutable collection allows for changes to be made, such as adding, removing, or updating stored items. Immutable variables, declared using the `val` keyword, are particularly useful for exposing internal state in a safe and controlled manner, as they cannot be modified by external code.">immutable</a> list (for example, <code class="language-kotlin">listOf</code>) can only be read, not modified.</p></li></ul></li><li><p><strong>Functions</strong>:</p><ul><li><p><code class="language-kotlin">MutableList</code> includes functions such as <code class="language-kotlin">add</code>, <code class="language-kotlin">remove</code>, and <code class="language-kotlin">clear</code>.</p></li><li><p>These <a href="/learn/step/0" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a function is a sequence of instructions that performs a specific action, such as printing data to standard output or calculating a square root. | It is a named block of code that can be invoked from a program using its name followed by parentheses. If a function takes one or more arguments (input data), they should be passed in the parentheses. Functions can return a result that can be assigned to a variable. Some functions, like regular math functions, take arguments and produce a result.">functions</a> are not available for the immutable list.</p></li></ul></li></ol>
<h5 id="initializing">Initializing</h5>
<p>Here is how you can <a class="theory-lookup not-relevant" href="/learn/step/11032" target="_blank" title="In Kotlin, initialization refers to the assignment of an initial value to a variable when it is declared. | This can be done using the `=` symbol followed by the value. When using the `val` keyword, initialization is required. If the base class has a constructor parameter, the derived class must take care of it. Kotlin will not allow a program to compile if the base class is not properly initiated. Initialization is a lightweight operation for simple objects, but creating instances of more complex classes can be expensive.">initialize</a> <code class="language-kotlin">MutableList</code>:</p>
<pre><code class="language-kotlin">val cars = mutableListOf("Ford", "Toyota", "Audi", "Mazda", "Tesla")
println(cars) // output: [Ford, Toyota, Audi, Mazda, Tesla]</code></pre>
<p>That is it! Here, we didn't even need to specify the type for our objects because it can be derived from the context. However, note that if you create an empty <code class="language-kotlin">MutableList</code>, you do have to specify the type:</p>
<pre><code class="language-kotlin">val cars = mutableListOf&lt;String&gt;()
println(cars) // output: []</code></pre>
<p>You can also transform <code class="language-kotlin">List</code> into a <code class="language-kotlin">MutableList</code> with the help of the function <code class="language-kotlin">toMutableList()</code>. If you want to transform <code class="language-kotlin">MutableList</code>into a <code class="language-kotlin">List</code>, you can use <code class="language-kotlin">toList()</code>:</p>
<pre><code class="language-kotlin">val cars = listOf("Ford", "Toyota").toMutableList()
cars.add("Tesla")
println(cars) // output: [Ford, Toyota, Tesla]
val carsList = cars.toList()</code></pre>
<h5 id="adding-and-replacing-elements">Adding and replacing elements</h5>
<p><code class="language-kotlin">MutableList</code> has the same properties and methods as <code class="language-kotlin">List</code>: <code class="language-kotlin">size</code>, <code class="language-kotlin">get(index)</code>, <code class="language-kotlin">isEmpty()</code>, <code class="language-kotlin">indexOf(element)</code>, <code class="language-kotlin">contains(element)</code>, and so on.</p>
<p>Since <code class="language-kotlin">MutableList</code> is special because it can be modified, it has additional functionality for changing the contents:</p>
<ul><li><p><code class="language-kotlin">add(element)</code> is a method that adds an extra element to your list.</p></li><li><p><code class="language-kotlin">set(index, element)</code> replaces the element at the specified position with the specified element. Laconic form:<br/><code class="language-kotlin">mutableList[index] = element</code></p></li><li><p><code class="language-kotlin">addAll(elements)</code> adds all of the elements of the specified collection to the end of the list.</p></li></ul>
<p>Let's take a look at some examples. Imagine that you're about to go get groceries, so you're making a <code class="language-kotlin">List</code> of products you need:</p>
<pre><code class="language-kotlin">val products = listOf("Milk", "Cheese", "Coke")</code></pre>
<p>You had a change of heart: suddenly, you decided that you also need to get some chips, and maybe get water instead of milk. Let's update our list of products:</p>
<pre><code class="language-kotlin">val finalList = products.toMutableList()
finalList.add("Chips")
finalList[0] = "Water" // or finalList.set(0, "Water")
println(finalList) // output: [Water, Cheese, Coke, Chips]</code></pre>
<p>Then, let's say your dad came in and gave you his grocery list. Okay, let's add these products to our list as well:</p>
<pre><code class="language-kotlin">val products = mutableListOf("Milk", "Cheese", "Coke")
val dadsProducts = listOf("Banana", "Watermelon", "Apple")

products.addAll(dadsProducts)

println(products) // output: [Milk, Cheese, Coke, Banana, Watermelon, Apple]</code></pre>
<h5 id="removing-elements">Removing elements</h5>
<p>You might also need to remove some or all elements from your list. Let's see how this can be done:</p>
<ul><li><p><code class="language-kotlin">removeAt(index)</code> removes an element at a specified index.</p></li><li><p><code class="language-kotlin">remove(element)</code> remove the first occurrence of the specified element.</p></li><li><p><code class="language-kotlin">clear()</code> removes all elements from the current collection.</p></li></ul>
<p>Let's go back to our grocery list. As you were getting dressed, you gradually realized that you actually had all this food in your fridge. One by one, you decided to clear your list of these products:</p>
<pre><code class="language-kotlin">val products = mutableListOf("Milk", "Cheese", "Coke")

products.removeAt(0)
println(products) // output: [Cheese, Coke]

products.remove("Coke")
println(products) // output: [Cheese]

products.clear()
println(products) // output: []</code></pre>
<p>This is not an exhaustive list of methods you can use. To learn about other <code class="language-kotlin">MutableList</code> methods, check out <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/" rel="noopener noreferrer nofollow" target="_blank">kotlinlang.org</a>.</p>
<h5 id="iterating-through-elements">Iterating through elements</h5>
<p>You can iterate through the elements in <code class="language-kotlin">MutableList</code> with the help of the <code class="language-kotlin">for</code> loop. Here is an example:</p>
<pre><code class="language-kotlin">val products = mutableListOf("Cheese", "Milk", "Coke")

for (product in products) {
    println("$product")
}

// Cheese
// Milk
// Coke</code></pre>
<p>We iterated through our <code class="language-kotlin">MutableList</code> and printed the name of each product.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Now you know the difference between a <code class="language-kotlin">List</code> and a <code class="language-kotlin">MutableList</code>. <code class="language-kotlin">List</code> is <strong>immutable</strong>, so use it when you don't want the content to change. <code class="language-kotlin">MutableList</code> is useful when you know that its contents will need some modifications in the future. Now you know how to initialize a <code class="language-kotlin">MutableList</code> and add, replace, and remove elements from it. You also know how to make a <code class="language-kotlin">List</code> mutable and iterate through its elements using the <code class="language-kotlin">for</code> loop. Note that you can solve problems on this topic with immutable lists if you're an avid programmer, but while we're just learning, we'll use <a class="theory-lookup not-relevant" href="/learn/step/11032" target="_blank" title="In Kotlin, a mutable list is a dynamic and flexible collection type that allows you to change its content after creation. | This makes it suitable for situations where the size and elements of the list may change during a program's execution. You can add or replace elements using functions like `add()` and `set()`, and remove elements using functions like `remove()` and `removeAt()`. Iterating through the elements can be done using functions like `forEach()`. In contrast, use an immutable list when working with a specific set of elements that should not change, as it offers protection against unintended alteration, making your code more reliable and easier to understand. The choice between a mutable and read-only list depends on whether the list's content is expected to be altered post-creation.">mutable lists</a>.</p>
</div>